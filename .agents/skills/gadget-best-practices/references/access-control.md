# Access Control

**üìñ Full docs:** [docs.gadget.dev/guides/access-control](https://docs.gadget.dev/guides/access-control.md)

Gadget has a built-in RBAC system. All operations automatically enforce permissions.

## Key Principles

- All actions have permissions
- Permissions granted to roles
- Users assigned roles via `roleList` field
- No transitive/inherited permissions

## Roles

### Built-In Roles

**unauthenticated** - Public access
**signed-in** - Authenticated users
**system-admin** - Super user (never grant explicitly - has all permissions)

### Custom Roles

Create in **Settings ‚Üí Roles** (e.g., `editor`, `admin`, `viewer`)

### User Roles

```javascript
await api.user.update("user-id", {
  roleList: ["signed-in", "editor"]
});
```

## Configuring Permissions

Permissions are configured in `accessControl/permissions.gadget.ts`. This file is auto-generated by Gadget based on your role and permission settings in the IDE, but you can also edit it directly.

The file structure uses roles as the top-level keys, with permissions defined per model:

```typescript
import type { GadgetPermissions } from "gadget-server";

export const permissions: GadgetPermissions = {
  type: "gadget/permissions/v1",
  roles: {
    "signed-in": {
      storageKey: "signed-in",
      default: {
        read: true,
        action: true,
      },
      models: {
        post: {
          read: true,  // Grant read permission
          actions: {
            create: true,
            update: true,
            delete: false
          }
        }
      }
    }
  }
};
```

## Permission Filters

Use Gelly filter snippets to limit access to record subsets. Filters are stored as separate `.gelly` files and referenced by path:

### Common Patterns

**World Readable (no filter):**
```typescript
models: {
  post: {
    read: true  // All records visible
  }
}
```

**User-Scoped (own records only):**
Create `accessControl/filters/post/tenant.gelly`:
```gelly
filter ($session: Session) on Post [
  where userId == $session.userId
]
```

Then reference in permissions:
```typescript
models: {
  post: {
    read: { filter: "accessControl/filters/post/tenant.gelly" }
  }
}
```

**Shop-Scoped (multi-tenant):**
Create `accessControl/filters/product/shop-tenant.gelly`:
```gelly
filter ($session: Session) on Product [
  where shopId == $session.shopId
]
```

Reference in permissions:
```typescript
models: {
  product: {
    read: { filter: "accessControl/filters/product/shop-tenant.gelly" }
  }
}
```

**Status-based:**
Create `accessControl/filters/post/published.gelly`:
```gelly
filter ($session: Session) on Post [
  where status == 'published' OR userId == $session.userId
]
```

## Multi-Tenancy

Every multi-tenant model needs:

1. **`belongsTo` to tenancy model** (e.g., `shop`, `organization`, `user`)
2. Gelly **permission filter** on that field

```typescript
// api/models/product/schema.gadget.ts
import type { GadgetModel } from "gadget-server";

export const schema: GadgetModel = {
  type: "gadget/model-schema/v2",
  storageKey: "Cde789FghIjk",
  fields: {
    shop: {
      type: "belongsTo",
      parent: { model: "shopifyShop" },
      storageKey: "Lmn012OpqRst",
    },
  },
};
```

```typescript
// In accessControl/permissions.gadget.ts
roles: {
  "shopify-app-users": {
    storageKey: "shopify-app-users",
    default: {
      read: false,
      action: false,
    },
    models: {
      product: {
        read: { filter: "accessControl/filters/product/shop-tenant.gelly" }
      }
    }
  }
}
```

**CRITICAL:** No transitive permissions - add filters to EVERY model.

### Denormalized Tenancy

Prefer direct relationships over traversing:

‚úÖ **Good:**
```typescript
// api/models/comment/schema.gadget.ts
import type { GadgetModel } from "gadget-server";

export const schema: GadgetModel = {
  type: "gadget/model-schema/v2",
  storageKey: "Uvw345XyzAbc",
  fields: {
    shop: {
      type: "belongsTo",
      parent: { model: "shopifyShop" },
      storageKey: "Def678GhiJkl",  // Direct relationship
    },
  },
};
```

```gelly
filter ($session: Session) on Comment [
  where shopId == $session.shopId
]
```

‚ùå **Avoid:**
```typescript
// api/models/comment/schema.gadget.ts
import type { GadgetModel } from "gadget-server";

export const schema: GadgetModel = {
  type: "gadget/model-schema/v2",
  storageKey: "Mno901PqrStu",
  fields: {
    post: {
      type: "belongsTo",
      parent: { model: "post" },
      storageKey: "Vwx234YzaBcd",  // Indirect - no direct shop
    },
  },
};
```

```gelly
// Slower - traverses relationship
filter ($session: Session) on Comment [
  where post.shopId == $session.shopId
]
```

## Internal API

Bypasses permissions, validations, and action lifecycle. Actions are not run when using the internal API.

‚úÖ **Use only when direct database updates are needed** (in backend code - actions, routes):
```javascript
const allPosts = await api.internal.post.findMany();
```

‚ùå **NOT available in frontend** - The internal API does not exist in the frontend and cannot be called from frontend code

‚ö†Ô∏è **Important:** The internal API bypasses the action lifecycle (`run`, `onSuccess`, etc.). Use regular API calls (`api.post.create()`) if you need actions to execute.

## Example: Blog App

```typescript
import type { GadgetPermissions } from "gadget-server";

export const permissions: GadgetPermissions = {
  type: "gadget/permissions/v1",
  roles: {
    unauthenticated: {
      storageKey: "unauthenticated",
      default: {
        read: false,
        action: false,
      },
      models: {
        user: {
          actions: {
            signUp: true,  // Allow sign up
            signIn: true
          }
        },
        post: {
          read: { filter: "accessControl/filters/post/published.gelly" }
        }
      }
    },
    "signed-in": {
      storageKey: "signed-in",
      default: {
        read: true,
        action: true,
      },
      models: {
        user: {
          read: { filter: "accessControl/filters/user/tenant.gelly" },
          actions: {
            update: { filter: "accessControl/filters/user/tenant.gelly" },
            signOut: { filter: "accessControl/filters/user/tenant.gelly" }
          }
        },
        post: {
          read: { filter: "accessControl/filters/post/user-or-published.gelly" },
          actions: {
            create: true,
            update: { filter: "accessControl/filters/post/author.gelly" }
          }
        }
      }
    },
    admin: {
      storageKey: "admin",
      default: {
        read: true,
        action: true,
      },
      models: {
        post: {
          read: true,
          actions: {
            delete: true
          }
        }
      }
    }
  }
};
```

## Best Practices

**DO:**
- ‚úÖ Grant permissions explicitly to each role
- ‚úÖ Add filters for multi-tenant models
- ‚úÖ Use denormalized tenancy (direct relationships)
- ‚úÖ Test with different roles
- ‚úÖ Check routes manually (not auto-enforced)

**DON'T:**
- ‚ùå Grant explicit permissions to `system-admin`
- ‚ùå Assume transitive permissions
- ‚ùå Try to use internal API from frontend (it doesn't exist there)
- ‚ùå Delete/rename built-in roles or `session` model

## Common Mistakes

1. **Missing tenancy filters** - Data leaks
2. **Assuming transitive permissions** - Each model needs its own filter
3. **Traversing relationships** - Prefer direct
4. **Trying to use internal API from frontend** - It doesn't exist in the frontend

## See Also

- [shopify-multi-tenancy.md](shopify-multi-tenancy.md) - Shop isolation
- [actions.md](actions.md) - How actions enforce permissions

**üìñ More info:**
- [Access control overview](https://docs.gadget.dev/guides/access-control.md)
- [Gelly filter syntax](https://docs.gadget.dev/reference/gelly.md)
- [Gelly data access](https://docs.gadget.dev/guides/data-access/gelly.md)
  